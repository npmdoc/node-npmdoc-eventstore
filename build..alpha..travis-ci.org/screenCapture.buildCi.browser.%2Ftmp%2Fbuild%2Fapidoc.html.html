<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/adrai/node-eventstore">eventstore (v1.12.2)</a>
</h1>
<h4>Node-eventstore is a node.js module for multiple databases. It can be very useful as eventstore if you work with (d)ddd, cqrs, eventsourcing, commands and events, etc.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventstore">module eventstore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore">
            function <span class="apidocSignatureSpan"></span>eventstore
            <span class="apidocSignatureSpan">(options, store)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store">
            function <span class="apidocSignatureSpan">eventstore.</span>Store
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventDispatcher">
            function <span class="apidocSignatureSpan">eventstore.</span>eventDispatcher
            <span class="apidocSignatureSpan">(publisher, store)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventStream">
            function <span class="apidocSignatureSpan">eventstore.</span>eventStream
            <span class="apidocSignatureSpan">(eventstore, query, events)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory">
            function <span class="apidocSignatureSpan">eventstore.</span>inmemory
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eventstore.</span>Store.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eventstore.</span>eventDispatcher.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eventstore.</span>eventStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eventstore.</span>eventstore.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eventstore.</span>inmemory.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventstore.Store">module eventstore.Store</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.Store">
            function <span class="apidocSignatureSpan">eventstore.</span>Store
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.super_">
            function <span class="apidocSignatureSpan">eventstore.Store.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.use">
            function <span class="apidocSignatureSpan">eventstore.Store.</span>use
            <span class="apidocSignatureSpan">(toRequire)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventstore.Store.prototype">module eventstore.Store.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.addEvents">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>addEvents
            <span class="apidocSignatureSpan">(evts, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.addSnapshot">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>addSnapshot
            <span class="apidocSignatureSpan">(snap, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.cleanSnapshots">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>cleanSnapshots
            <span class="apidocSignatureSpan">(query, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.clear">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>clear
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.connect">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>connect
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.disconnect">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>disconnect
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.getEvents">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getEvents
            <span class="apidocSignatureSpan">(query, skip, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.getEventsByRevision">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getEventsByRevision
            <span class="apidocSignatureSpan">(query, revMin, revMax, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.getEventsSince">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getEventsSince
            <span class="apidocSignatureSpan">(commitStamp, skip, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.getLastEvent">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getLastEvent
            <span class="apidocSignatureSpan">(query, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.getNewId">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getNewId
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.getSnapshot">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getSnapshot
            <span class="apidocSignatureSpan">(query, revMax, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.getUndispatchedEvents">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getUndispatchedEvents
            <span class="apidocSignatureSpan">(query, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.Store.prototype.setEventToDispatched">
            function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>setEventToDispatched
            <span class="apidocSignatureSpan">(id, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventstore.eventDispatcher">module eventstore.eventDispatcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventDispatcher.eventDispatcher">
            function <span class="apidocSignatureSpan">eventstore.</span>eventDispatcher
            <span class="apidocSignatureSpan">(publisher, store)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventstore.eventDispatcher.prototype">module eventstore.eventDispatcher.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventDispatcher.prototype.addUndispatchedEvents">
            function <span class="apidocSignatureSpan">eventstore.eventDispatcher.prototype.</span>addUndispatchedEvents
            <span class="apidocSignatureSpan">(events)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventDispatcher.prototype.start">
            function <span class="apidocSignatureSpan">eventstore.eventDispatcher.prototype.</span>start
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventstore.eventStream">module eventstore.eventStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventStream.eventStream">
            function <span class="apidocSignatureSpan">eventstore.</span>eventStream
            <span class="apidocSignatureSpan">(eventstore, query, events)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventstore.eventStream.prototype">module eventstore.eventStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventStream.prototype.addEvent">
            function <span class="apidocSignatureSpan">eventstore.eventStream.prototype.</span>addEvent
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventStream.prototype.addEvents">
            function <span class="apidocSignatureSpan">eventstore.eventStream.prototype.</span>addEvents
            <span class="apidocSignatureSpan">(events)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventStream.prototype.commit">
            function <span class="apidocSignatureSpan">eventstore.eventStream.prototype.</span>commit
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventStream.prototype.currentRevision">
            function <span class="apidocSignatureSpan">eventstore.eventStream.prototype.</span>currentRevision
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventstore.eventstore">module eventstore.eventstore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.eventstore">
            function <span class="apidocSignatureSpan">eventstore.</span>eventstore
            <span class="apidocSignatureSpan">(options, store)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.super_">
            function <span class="apidocSignatureSpan">eventstore.eventstore.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventstore.eventstore.prototype">module eventstore.eventstore.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.commit">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>commit
            <span class="apidocSignatureSpan">(eventstream, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.createSnapshot">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>createSnapshot
            <span class="apidocSignatureSpan">(obj, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.defineEventMappings">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>defineEventMappings
            <span class="apidocSignatureSpan">(mappings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.getEventStream">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getEventStream
            <span class="apidocSignatureSpan">(query, revMin, revMax, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.getEvents">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getEvents
            <span class="apidocSignatureSpan">(query, skip, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.getEventsByRevision">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getEventsByRevision
            <span class="apidocSignatureSpan">(query, revMin, revMax, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.getEventsSince">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getEventsSince
            <span class="apidocSignatureSpan">(commitStamp, skip, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.getFromSnapshot">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getFromSnapshot
            <span class="apidocSignatureSpan">(query, revMax, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.getLastEvent">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getLastEvent
            <span class="apidocSignatureSpan">(query, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.getLastEventAsStream">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getLastEventAsStream
            <span class="apidocSignatureSpan">(query, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.getNewId">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getNewId
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.getUndispatchedEvents">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getUndispatchedEvents
            <span class="apidocSignatureSpan">(query, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.init">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>init
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.setEventToDispatched">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>setEventToDispatched
            <span class="apidocSignatureSpan">(evtOrId, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.eventstore.prototype.useEventPublisher">
            function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>useEventPublisher
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventstore.inmemory">module eventstore.inmemory</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.inmemory">
            function <span class="apidocSignatureSpan">eventstore.</span>inmemory
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.super_">
            function <span class="apidocSignatureSpan">eventstore.inmemory.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventstore.inmemory.prototype">module eventstore.inmemory.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.addEvents">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>addEvents
            <span class="apidocSignatureSpan">(events, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.addSnapshot">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>addSnapshot
            <span class="apidocSignatureSpan">(snap, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.cleanSnapshots">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>cleanSnapshots
            <span class="apidocSignatureSpan">(query, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.clear">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>clear
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.connect">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>connect
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.disconnect">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>disconnect
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.getEvents">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>getEvents
            <span class="apidocSignatureSpan">(query, skip, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.getEventsByRevision">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>getEventsByRevision
            <span class="apidocSignatureSpan">(query, revMin, revMax, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.getEventsSince">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>getEventsSince
            <span class="apidocSignatureSpan">(date, skip, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.getLastEvent">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>getLastEvent
            <span class="apidocSignatureSpan">(query, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.getSnapshot">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>getSnapshot
            <span class="apidocSignatureSpan">(query, revMax, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.getUndispatchedEvents">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>getUndispatchedEvents
            <span class="apidocSignatureSpan">(query, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventstore.inmemory.prototype.setEventToDispatched">
            function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>setEventToDispatched
            <span class="apidocSignatureSpan">(id, callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventstore" id="apidoc.module.eventstore">module eventstore</a></h1>


    <h2>
        <a href="#apidoc.element.eventstore.eventstore" id="apidoc.element.eventstore.eventstore">
        function <span class="apidocSignatureSpan"></span>eventstore
        <span class="apidocSignatureSpan">(options, store)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Eventstore(options, store) {
  this.options = options || {};
  this.store = store;

  this.eventMappings = {};

  EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store" id="apidoc.element.eventstore.Store">
        function <span class="apidocSignatureSpan">eventstore.</span>Store
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Store(options) {
  options = options || {};

  EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventDispatcher" id="apidoc.element.eventstore.eventDispatcher">
        function <span class="apidocSignatureSpan">eventstore.</span>eventDispatcher
        <span class="apidocSignatureSpan">(publisher, store)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventDispatcher(publisher, store) {
  this.publisher = publisher;
  this.store = store;
  this.undispatchedEventsQueue = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventStream" id="apidoc.element.eventstore.eventStream">
        function <span class="apidocSignatureSpan">eventstore.</span>eventStream
        <span class="apidocSignatureSpan">(eventstore, query, events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventStream(eventstore, query, events) {
  if (!eventstore) {
    var errESMsg = 'eventstore not injected!';
    debug(errESMsg);
    throw new Error(errESMsg);
  }

  if (typeof eventstore.commit !== 'function') {
    var errESfnMsg = 'eventstore.commit not injected!';
    debug(errESfnMsg);
    throw new Error(errESfnMsg);
  }

  if (!query) {
    var errQryMsg = 'query not injected!';
    debug(errQryMsg);
    throw new Error(errQryMsg);
  }

  if (!query.aggregateId) {
    var errAggIdMsg = 'query.aggregateId not injected!';
    debug(errAggIdMsg);
    throw new Error(errAggIdMsg);
  }

  if (events) {
    if (!_.isArray(events)) {
      var errEvtsArrMsg = 'events should be an array!';
      debug(errEvtsArrMsg);
      throw new Error(errEvtsArrMsg);
    }

    for (var i = 0, len = events.length; i &lt; len; i++) {
      var evt = events[i];
      if (evt.streamRevision === undefined || evt.streamRevision === null) {
        var errEvtMsg = 'The events passed should all have a streamRevision!';
        debug(errEvtMsg);
        throw new Error(errEvtMsg);
      }
    }
  }

  this.eventstore = eventstore;
  this.streamId = query.aggregateId;
  this.aggregateId = query.aggregateId;
  this.aggregate = query.aggregate;
  this.context = query.context;
  this.events = events || [];
  this.uncommittedEvents = [];
  this.lastRevision = -1;

  this.events = _.sortBy(this.events, 'streamRevision');

  // to update lastRevision...
  this.currentRevision();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory" id="apidoc.element.eventstore.inmemory">
        function <span class="apidocSignatureSpan">eventstore.</span>inmemory
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InMemory(options) {
  Store.call(this, options);
  this.store = {};
  this.snapshots = {};
  this.undispatchedEvents = { _direct: {} };
  this.options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventstore.Store" id="apidoc.module.eventstore.Store">module eventstore.Store</a></h1>


    <h2>
        <a href="#apidoc.element.eventstore.Store.Store" id="apidoc.element.eventstore.Store.Store">
        function <span class="apidocSignatureSpan">eventstore.</span>Store
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Store(options) {
  options = options || {};

  EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.super_" id="apidoc.element.eventstore.Store.super_">
        function <span class="apidocSignatureSpan">eventstore.Store.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.use" id="apidoc.element.eventstore.Store.use">
        function <span class="apidocSignatureSpan">eventstore.Store.</span>use
        <span class="apidocSignatureSpan">(toRequire)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (toRequire) {
  var required;
  try {
    required = require(toRequire);
  } catch (e) {
    // workaround when `npm link`'ed for development
    required = prequire(toRequire);
  }
  return required;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventstore.Store.prototype" id="apidoc.module.eventstore.Store.prototype">module eventstore.Store.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.addEvents" id="apidoc.element.eventstore.Store.prototype.addEvents">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>addEvents
        <span class="apidocSignatureSpan">(evts, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addEvents = function (evts, callback) {
  implementError(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// myAggregate.loadFromHistory(history);
    });

store a new event and commit it to store

    es.getEventStream('streamId', function(err, stream) {
stream.addEvent({ my: 'event' });
stream.<span class="apidocCodeKeywordSpan">addEvents</span>([{ my: 'event2' }]);

stream.commit();

// or

stream.commit(function(err, stream) {
  console.log(stream.eventsToDispatch); // this is an array containing all added events in this commit.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.addSnapshot" id="apidoc.element.eventstore.Store.prototype.addSnapshot">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>addSnapshot
        <span class="apidocSignatureSpan">(snap, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addSnapshot = function (snap, callback) {
  implementError(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  try {
    var snap = new Snapshot(id, obj);
    snap.commitStamp = new Date();
  } catch (err) {
    return callback(err);
  }

  self.store.<span class="apidocCodeKeywordSpan">addSnapshot</span>(snap, function(error) {
    if (self.options.maxSnapshotsCount) {
      self.store.cleanSnapshots(_.pick(obj, 'aggregateId', 'aggregate', 'context'), callback);
    } else {
      callback(error);
    }
  });
}],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.cleanSnapshots" id="apidoc.element.eventstore.Store.prototype.cleanSnapshots">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>cleanSnapshots
        <span class="apidocSignatureSpan">(query, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanSnapshots = function (query, callback) {
  silentWarning(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        snap.commitStamp = new Date();
      } catch (err) {
        return callback(err);
      }

      self.store.addSnapshot(snap, function(error) {
        if (self.options.maxSnapshotsCount) {
          self.store.<span class="apidocCodeKeywordSpan">cleanSnapshots</span>(_.pick(obj, 'aggregateId', 'aggregate
', 'context'), callback);
        } else {
          callback(error);
        }
      });
    }],
  callback
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.clear" id="apidoc.element.eventstore.Store.prototype.clear">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>clear
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function (callback) {
  implementError(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.connect" id="apidoc.element.eventstore.Store.prototype.connect">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>connect
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function implementError(callback) {
  var err = new Error('Please implement this function!');
  if (callback) callback(err);
  throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this.store.on('disconnect', function () {
  self.emit('disconnect');
});

process.nextTick(function() {
  tolerate(function(callback) {
    self.store.<span class="apidocCodeKeywordSpan">connect</span>(callback);
  }, self.options.timeout || 0, function (err) {
    if (err) {
      debug(err);
      if (callback) callback(err);
      return;
    }
    if (!self.publisher) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.disconnect" id="apidoc.element.eventstore.Store.prototype.disconnect">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>disconnect
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function implementError(callback) {
  var err = new Error('Please implement this function!');
  if (callback) callback(err);
  throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.getEvents" id="apidoc.element.eventstore.Store.prototype.getEvents">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getEvents
        <span class="apidocSignatureSpan">(query, skip, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEvents = function (query, skip, limit, callback) {
  implementError(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for replaying your events or for rebuilding a viewmodel or just for fun...

skip, limit always optional

var skip = 0,
    limit = 100; // if you omit limit or you define it as -1 it will retrieve until the end

es.<span class="apidocCodeKeywordSpan">getEvents</span>(skip, limit, function(err, evts) {
  // if (events.length === amount) {
  //   events.next(function (err, nextEvts) {}); // just call next to retrieve the next page...
  // } else {
  //   // finished...
  // }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.getEventsByRevision" id="apidoc.element.eventstore.Store.prototype.getEventsByRevision">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getEventsByRevision
        <span class="apidocSignatureSpan">(query, revMin, revMax, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEventsByRevision = function (query, revMin, revMax, callback) {
  implementError(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
by revision

revMin, revMax always optional

var revMin = 5,
    revMax = 8; // if you omit revMax or you define it as -1 it will retrieve until the end

es.<span class="apidocCodeKeywordSpan">getEventsByRevision</span>('streamId', revMin, revMax, function(err, evts) {});

// or

es.getEventsByRevision({
  aggregateId: 'myAggregateId',
  aggregate: 'person',          // optional
  context: 'hr'                 // optional
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.getEventsSince" id="apidoc.element.eventstore.Store.prototype.getEventsSince">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getEventsSince
        <span class="apidocSignatureSpan">(commitStamp, skip, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEventsSince = function (commitStamp, skip, limit, callback) {
  implementError(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
by commitStamp

skip, limit always optional

var skip = 0,
    limit = 100; // if you omit limit or you define it as -1 it will retrieve until the end

es.<span class="apidocCodeKeywordSpan">getEventsSince</span>(new Date(2015, 5, 23), skip, limit, function(err, evts) {
  // if (events.length === amount) {
  //   events.next(function (err, nextEvts) {}); // just call next to retrieve the next page...
  // } else {
  //   // finished...
  // }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.getLastEvent" id="apidoc.element.eventstore.Store.prototype.getLastEvent">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getLastEvent
        <span class="apidocSignatureSpan">(query, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastEvent = function (query, callback) {
  implementError(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // }
});


## get the last event
for example to obtain the last revision nr

es.<span class="apidocCodeKeywordSpan">getLastEvent</span>('streamId', function(err, evt) {
});

// or

es.getLastEvent({ // free choice (all, only context, only aggregate, only aggregateId...)
  context: 'hr',
  aggregate: 'person',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.getNewId" id="apidoc.element.eventstore.Store.prototype.getNewId">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getNewId
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNewId = function (callback) {
  var id = uuid().toString();
  if (callback) callback(null, id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  aggregateId: 'uuid'
} function(err, evt) {
});


## obtain a new id

es.<span class="apidocCodeKeywordSpan">getNewId</span>(function(err, newId) {
  if(err) {
    console.log('ohhh :-(');
    return;
  }

  console.log('the new id is: ' + newId);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.getSnapshot" id="apidoc.element.eventstore.Store.prototype.getSnapshot">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getSnapshot
        <span class="apidocSignatureSpan">(query, revMax, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSnapshot = function (query, revMax, callback) {
  implementError(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var self = this;

    async.waterfall([

      function getSnapshot(callback) {
self.store.<span class="apidocCodeKeywordSpan">getSnapshot</span>(query, revMax, callback);
      },

      function getEventStream(snap, callback) {
var rev = 0;

if (snap &amp;&amp; (snap.revision !== undefined &amp;&amp; snap.revision !== null)) {
  rev = snap.revision + 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.getUndispatchedEvents" id="apidoc.element.eventstore.Store.prototype.getUndispatchedEvents">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>getUndispatchedEvents
        <span class="apidocSignatureSpan">(query, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUndispatchedEvents = function (query, callback) {
  implementError(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

});

You can automatically clean older snapshots by configuring the number of snapshots to keep with `maxSnapshotsCount` in `eventstore
` options.

## own event dispatching (no event publisher function defined)

es.<span class="apidocCodeKeywordSpan">getUndispatchedEvents</span>(function(err, evts) {
// or es.getUndispatchedEvents('streamId', function(err, evts) {
// or es.getUndispatchedEvents({ // free choice (all, only context, only aggregate, only aggregateId...)
//                                context: 'hr',
//                                aggregate: 'person',
//                                aggregateId: 'uuid'
//                              }, function(err, evts) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.Store.prototype.setEventToDispatched" id="apidoc.element.eventstore.Store.prototype.setEventToDispatched">
        function <span class="apidocSignatureSpan">eventstore.Store.prototype.</span>setEventToDispatched
        <span class="apidocSignatureSpan">(id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEventToDispatched = function (id, callback) {
  implementError(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // all undispatched events
  console.log(evts);

  // dispatch it and set the event as dispatched

  for (var e in evts) {
    var evt = evts[r];
    es.<span class="apidocCodeKeywordSpan">setEventToDispatched</span>(evt, function(err) {});
    // or
    es.setEventToDispatched(evt.id, function(err) {});
  }

});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventstore.eventDispatcher" id="apidoc.module.eventstore.eventDispatcher">module eventstore.eventDispatcher</a></h1>


    <h2>
        <a href="#apidoc.element.eventstore.eventDispatcher.eventDispatcher" id="apidoc.element.eventstore.eventDispatcher.eventDispatcher">
        function <span class="apidocSignatureSpan">eventstore.</span>eventDispatcher
        <span class="apidocSignatureSpan">(publisher, store)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventDispatcher(publisher, store) {
  this.publisher = publisher;
  this.store = store;
  this.undispatchedEventsQueue = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventstore.eventDispatcher.prototype" id="apidoc.module.eventstore.eventDispatcher.prototype">module eventstore.eventDispatcher.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.eventstore.eventDispatcher.prototype.addUndispatchedEvents" id="apidoc.element.eventstore.eventDispatcher.prototype.addUndispatchedEvents">
        function <span class="apidocSignatureSpan">eventstore.eventDispatcher.prototype.</span>addUndispatchedEvents
        <span class="apidocSignatureSpan">(events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addUndispatchedEvents = function (events) {
  var self = this;
  events.forEach(function(event) {
    self.undispatchedEventsQueue.push(event);
  });
  trigger(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // add uncommitted events back to eventstream
  eventstream.uncommittedEvents = uncommittedEvents.concat(eventstream.uncommittedEvents);
  return callback(err);
}

if (self.publisher &amp;&amp; self.dispatcher) {
  // push to undispatchedQueue
  self.dispatcher.<span class="apidocCodeKeywordSpan">addUndispatchedEvents</span>(uncommittedEvents);
} else {
  eventstream.eventsToDispatch = [].concat(uncommittedEvents);
}

// move uncommitted events to events
eventstream.events = eventstream.events.concat(uncommittedEvents);
eventstream.currentRevision();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventDispatcher.prototype.start" id="apidoc.element.eventstore.eventDispatcher.prototype.start">
        function <span class="apidocSignatureSpan">eventstore.eventDispatcher.prototype.</span>start
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (callback) {

  if (typeof this.publisher !== 'function') {
    var pubErrMsg = 'publisher not injected!';
    debug(pubErrMsg);
    if (callback) callback(new Error(pubErrMsg));
    return;
  }

  if (!this.store || typeof this.store.getUndispatchedEvents !== 'function'
                  || typeof this.store.setEventToDispatched !== 'function') {
    var storeErrMsg = 'store not injected!';
    debug(storeErrMsg);
    if (callback) callback(new Error(storeErrMsg))
    return;
  }

  var self = this;

  // Get all undispatched events from store and queue them
  // before all other events passed in by the addUndispatchedEvents function.
  this.store.getUndispatchedEvents(function(err, events) {

    if (err) {
      debug(err);
      if (callback) callback(err);
      return;
    }

    var triggered = false;
    if (events) {
      for (var i = 0, len = events.length; i &lt; len; i++) {
        self.undispatchedEventsQueue.push(events[i]);
        // If there are a lot of events then we can hit issues with the call stack size when processing in one go
        triggered = false;
        if (i % 1000 === 0){
          triggered = true;
          trigger(self);
        }
      }
    }

    if (!triggered) {
      trigger(self);
    }

    if (callback) callback(null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  init: function (callback) {
var self = this;

function initDispatcher() {
  debug('init event dispatcher');
  self.dispatcher = new EventDispatcher(self.publisher, self);
  self.dispatcher.<span class="apidocCodeKeywordSpan">start</span>(callback);
}

this.store.on('connect', function () {
  self.emit('connect');
});

this.store.on('disconnect', function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventstore.eventStream" id="apidoc.module.eventstore.eventStream">module eventstore.eventStream</a></h1>


    <h2>
        <a href="#apidoc.element.eventstore.eventStream.eventStream" id="apidoc.element.eventstore.eventStream.eventStream">
        function <span class="apidocSignatureSpan">eventstore.</span>eventStream
        <span class="apidocSignatureSpan">(eventstore, query, events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventStream(eventstore, query, events) {
  if (!eventstore) {
    var errESMsg = 'eventstore not injected!';
    debug(errESMsg);
    throw new Error(errESMsg);
  }

  if (typeof eventstore.commit !== 'function') {
    var errESfnMsg = 'eventstore.commit not injected!';
    debug(errESfnMsg);
    throw new Error(errESfnMsg);
  }

  if (!query) {
    var errQryMsg = 'query not injected!';
    debug(errQryMsg);
    throw new Error(errQryMsg);
  }

  if (!query.aggregateId) {
    var errAggIdMsg = 'query.aggregateId not injected!';
    debug(errAggIdMsg);
    throw new Error(errAggIdMsg);
  }

  if (events) {
    if (!_.isArray(events)) {
      var errEvtsArrMsg = 'events should be an array!';
      debug(errEvtsArrMsg);
      throw new Error(errEvtsArrMsg);
    }

    for (var i = 0, len = events.length; i &lt; len; i++) {
      var evt = events[i];
      if (evt.streamRevision === undefined || evt.streamRevision === null) {
        var errEvtMsg = 'The events passed should all have a streamRevision!';
        debug(errEvtMsg);
        throw new Error(errEvtMsg);
      }
    }
  }

  this.eventstore = eventstore;
  this.streamId = query.aggregateId;
  this.aggregateId = query.aggregateId;
  this.aggregate = query.aggregate;
  this.context = query.context;
  this.events = events || [];
  this.uncommittedEvents = [];
  this.lastRevision = -1;

  this.events = _.sortBy(this.events, 'streamRevision');

  // to update lastRevision...
  this.currentRevision();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventstore.eventStream.prototype" id="apidoc.module.eventstore.eventStream.prototype">module eventstore.eventStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.eventstore.eventStream.prototype.addEvent" id="apidoc.element.eventstore.eventStream.prototype.addEvent">
        function <span class="apidocSignatureSpan">eventstore.eventStream.prototype.</span>addEvent
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addEvent = function (event) {
  new Event(this, event, this.eventstore.eventMappings);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// myAggregate.loadFromHistory(history);
    });

store a new event and commit it to store

    es.getEventStream('streamId', function(err, stream) {
stream.<span class="apidocCodeKeywordSpan">addEvent</span>({ my: 'event' });
stream.addEvents([{ my: 'event2' }]);

stream.commit();

// or

stream.commit(function(err, stream) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventStream.prototype.addEvents" id="apidoc.element.eventstore.eventStream.prototype.addEvents">
        function <span class="apidocSignatureSpan">eventstore.eventStream.prototype.</span>addEvents
        <span class="apidocSignatureSpan">(events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addEvents = function (events) {
  if (!_.isArray(events)) {
    var errEvtsArrMsg = 'events should be an array!';
    debug(errEvtsArrMsg);
    throw new Error(errEvtsArrMsg);
  }
  var self = this;
  _.each(events, function(evt) {
    self.addEvent(evt);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// myAggregate.loadFromHistory(history);
    });

store a new event and commit it to store

    es.getEventStream('streamId', function(err, stream) {
stream.addEvent({ my: 'event' });
stream.<span class="apidocCodeKeywordSpan">addEvents</span>([{ my: 'event2' }]);

stream.commit();

// or

stream.commit(function(err, stream) {
  console.log(stream.eventsToDispatch); // this is an array containing all added events in this commit.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventStream.prototype.commit" id="apidoc.element.eventstore.eventStream.prototype.commit">
        function <span class="apidocSignatureSpan">eventstore.eventStream.prototype.</span>commit
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commit = function (callback) {
  this.eventstore.commit(this, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

store a new event and commit it to store

es.getEventStream('streamId', function(err, stream) {
  stream.addEvent({ my: 'event' });
  stream.addEvents([{ my: 'event2' }]);

  stream.<span class="apidocCodeKeywordSpan">commit</span>();

  // or

  stream.commit(function(err, stream) {
    console.log(stream.eventsToDispatch); // this is an array containing all added events in this commit.
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventStream.prototype.currentRevision" id="apidoc.element.eventstore.eventStream.prototype.currentRevision">
        function <span class="apidocSignatureSpan">eventstore.eventStream.prototype.</span>currentRevision
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">currentRevision = function () {
  for (var i = 0, len = this.events.length; i &lt; len; i++) {
    if (this.events[i].streamRevision &gt; this.lastRevision) {
      this.lastRevision = this.events[i].streamRevision;
    }
  }

  return this.lastRevision;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function getNewCommitId(callback) {
  self.getNewId(callback);
},

function commitEvents(id, callback) {
  // start committing.
  var event,
    currentRevision = eventstream.<span class="apidocCodeKeywordSpan">currentRevision</span>(),
    uncommittedEvents = [].concat(eventstream.uncommittedEvents);
  eventstream.uncommittedEvents = [];
  for (var i = 0, len = uncommittedEvents.length; i &lt; len; i++) {
    event = uncommittedEvents[i];
    event.id = id + i.toString();
    event.commitId = id;
    event.commitSequence = i;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventstore.eventstore" id="apidoc.module.eventstore.eventstore">module eventstore.eventstore</a></h1>


    <h2>
        <a href="#apidoc.element.eventstore.eventstore.eventstore" id="apidoc.element.eventstore.eventstore.eventstore">
        function <span class="apidocSignatureSpan">eventstore.</span>eventstore
        <span class="apidocSignatureSpan">(options, store)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Eventstore(options, store) {
  this.options = options || {};
  this.store = store;

  this.eventMappings = {};

  EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.super_" id="apidoc.element.eventstore.eventstore.super_">
        function <span class="apidocSignatureSpan">eventstore.eventstore.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventstore.eventstore.prototype" id="apidoc.module.eventstore.eventstore.prototype">module eventstore.eventstore.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.commit" id="apidoc.element.eventstore.eventstore.prototype.commit">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>commit
        <span class="apidocSignatureSpan">(eventstream, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commit = function (eventstream, callback) {

  var self = this;

  async.waterfall([

    function getNewCommitId(callback) {
      self.getNewId(callback);
    },

    function commitEvents(id, callback) {
      // start committing.
      var event,
        currentRevision = eventstream.currentRevision(),
        uncommittedEvents = [].concat(eventstream.uncommittedEvents);
      eventstream.uncommittedEvents = [];
      for (var i = 0, len = uncommittedEvents.length; i &lt; len; i++) {
        event = uncommittedEvents[i];
        event.id = id + i.toString();
        event.commitId = id;
        event.commitSequence = i;
        event.restInCommitStream = len - 1 - i;
        event.commitStamp = new Date();
        currentRevision++;
        event.streamRevision = currentRevision;

        event.applyMappings();
      }

      self.store.addEvents(uncommittedEvents, function(err) {
        if (err) {
          // add uncommitted events back to eventstream
          eventstream.uncommittedEvents = uncommittedEvents.concat(eventstream.uncommittedEvents);
          return callback(err);
        }

        if (self.publisher &amp;&amp; self.dispatcher) {
          // push to undispatchedQueue
          self.dispatcher.addUndispatchedEvents(uncommittedEvents);
        } else {
          eventstream.eventsToDispatch = [].concat(uncommittedEvents);
        }

        // move uncommitted events to events
        eventstream.events = eventstream.events.concat(uncommittedEvents);
        eventstream.currentRevision();

        callback(null, eventstream);
      });
    }],

    callback
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

store a new event and commit it to store

es.getEventStream('streamId', function(err, stream) {
  stream.addEvent({ my: 'event' });
  stream.addEvents([{ my: 'event2' }]);

  stream.<span class="apidocCodeKeywordSpan">commit</span>();

  // or

  stream.commit(function(err, stream) {
    console.log(stream.eventsToDispatch); // this is an array containing all added events in this commit.
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.createSnapshot" id="apidoc.element.eventstore.eventstore.prototype.createSnapshot">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>createSnapshot
        <span class="apidocSignatureSpan">(obj, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSnapshot = function (obj, callback) {
  if (obj.streamId &amp;&amp; !obj.aggregateId) {
    obj.aggregateId = obj.streamId;
  }

  if (!obj.aggregateId) {
    var err = new Error('An aggregateId should be passed!');
    debug(err);
    if (callback) callback(err);
    return;
  }

  obj.streamId = obj.aggregateId;

  var self = this;

  async.waterfall([
      function getNewIdFromStorage(callback) {
        self.getNewId(callback);
      },
      function commit(id, callback) {
        try {
          var snap = new Snapshot(id, obj);
          snap.commitStamp = new Date();
        } catch (err) {
          return callback(err);
        }

        self.store.addSnapshot(snap, function(error) {
          if (self.options.maxSnapshotsCount) {
            self.store.cleanSnapshots(_.pick(obj, 'aggregateId', 'aggregate', 'context'), callback);
          } else {
            callback(error);
          }
        });
      }],
    callback
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var history = stream.events; // events history from given snapshot

// myAggregate.loadSnapshot(snap);
// myAggregate.loadFromHistory(history);

// create a new snapshot depending on your rules
if (history.length &gt; myLimit) {
  es.<span class="apidocCodeKeywordSpan">createSnapshot</span>({
    streamId: 'streamId',
    data: myAggregate.getSnap(),
    revision: stream.lastRevision,
    version: 1 // optional
  }, function(err) {
    // snapshot saved
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.defineEventMappings" id="apidoc.element.eventstore.eventstore.prototype.defineEventMappings">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>defineEventMappings
        <span class="apidocSignatureSpan">(mappings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineEventMappings = function (mappings) {
  if (!mappings || !_.isObject(mappings)) {
    var err = new Error('Please pass a valid mapping values!');
    debug(err);
    throw err;
  }

  this.eventMappings = mappings;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.log('connection to storage is gone');
});


## define event mappings [optional]
Define which values should be mapped/copied to the payload event.

es.<span class="apidocCodeKeywordSpan">defineEventMappings</span>({
  id: 'id',
  commitId: 'commitId',
  commitSequence: 'commitSequence',
  commitStamp: 'commitStamp',
  streamRevision: 'streamRevision'
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.getEventStream" id="apidoc.element.eventstore.eventstore.prototype.getEventStream">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getEventStream
        <span class="apidocSignatureSpan">(query, revMin, revMax, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEventStream = function (query, revMin, revMax, callback) {
  if (typeof revMin === 'function') {
    callback = revMin;
    revMin = 0;
    revMax = -1;
  } else if (typeof revMax === 'function') {
    callback = revMax;
    revMax = -1;
  }

  if (typeof query === 'string') {
    query = { aggregateId: query };
  }

  if (!query.aggregateId) {
    var err = new Error('An aggregateId should be passed!');
    debug(err);
    if (callback) callback(err);
    return;
  }

  var self = this;

  this.getEventsByRevision(query, revMin, revMax, function(err, evts) {
    if (err) {
      return callback(err);
    }
    callback(null, new EventStream(self, query, evts));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ex.init(); // callback is optional


## working with the eventstore

### get the eventhistory (of an aggregate)

    es.<span class="apidocCodeKeywordSpan">getEventStream</span>('streamId', function(err, stream) {
      var history = stream.events; // the original event will be in events[i].payload

      // myAggregate.loadFromHistory(history);
    });

or
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.getEvents" id="apidoc.element.eventstore.eventstore.prototype.getEvents">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getEvents
        <span class="apidocSignatureSpan">(query, skip, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEvents = function (query, skip, limit, callback) {
  if (typeof query === 'function') {
    callback = query;
    skip = 0;
    limit = -1;
    query = {};
  } else if (typeof skip === 'function') {
    callback = skip;
    skip = 0;
    limit = -1;
    if (typeof query === 'number') {
      skip = query;
      query = {};
    }
  } else if (typeof limit === 'function') {
    callback = limit;
    limit = -1;
    if (typeof query === 'number') {
      limit = skip;
      skip = query;
      query = {};
    }
  }

  if (typeof query === 'string') {
    query = { aggregateId: query };
  }

  var self = this;

  this.store.getEvents(query, skip, limit, function (err, evts) {
    if (err) {
      return callback(err);
    }
    evts.next = function nextFn(callback) {
      if (limit &lt; 0) {
        var resEvts = [];
        resEvts.next = nextFn;
        return process.nextTick(function () { callback(null, resEvts) });
      }
      skip += limit;
      self.getEvents(query, skip, limit, callback);
    };

    callback(null, evts);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for replaying your events or for rebuilding a viewmodel or just for fun...

skip, limit always optional

var skip = 0,
    limit = 100; // if you omit limit or you define it as -1 it will retrieve until the end

es.<span class="apidocCodeKeywordSpan">getEvents</span>(skip, limit, function(err, evts) {
  // if (events.length === amount) {
  //   events.next(function (err, nextEvts) {}); // just call next to retrieve the next page...
  // } else {
  //   // finished...
  // }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.getEventsByRevision" id="apidoc.element.eventstore.eventstore.prototype.getEventsByRevision">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getEventsByRevision
        <span class="apidocSignatureSpan">(query, revMin, revMax, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEventsByRevision = function (query, revMin, revMax, callback) {
  if (typeof revMin === 'function') {
    callback = revMin;
    revMin = 0;
    revMax = -1;
  } else if (typeof revMax === 'function') {
    callback = revMax;
    revMax = -1;
  }

  if (typeof query === 'string') {
    query = { aggregateId: query };
  }

  if (!query.aggregateId) {
    var err = new Error('An aggregateId should be passed!');
    debug(err);
    if (callback) callback(err);
    return;
  }

  this.store.getEventsByRevision(query, revMin, revMax, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
by revision

revMin, revMax always optional

var revMin = 5,
    revMax = 8; // if you omit revMax or you define it as -1 it will retrieve until the end

es.<span class="apidocCodeKeywordSpan">getEventsByRevision</span>('streamId', revMin, revMax, function(err, evts) {});

// or

es.getEventsByRevision({
  aggregateId: 'myAggregateId',
  aggregate: 'person',          // optional
  context: 'hr'                 // optional
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.getEventsSince" id="apidoc.element.eventstore.eventstore.prototype.getEventsSince">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getEventsSince
        <span class="apidocSignatureSpan">(commitStamp, skip, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEventsSince = function (commitStamp, skip, limit, callback) {
  if (!commitStamp) {
    var err = new Error('Please pass in a date object!');
    debug(err);
    throw err;
  }

  commitStamp = new Date(commitStamp);

  if (typeof skip === 'function') {
    callback = skip;
    skip = 0;
    limit = -1;
  } else if (typeof limit === 'function') {
    callback = limit;
    limit = -1;
  }

  var self = this;

  this.store.getEventsSince(commitStamp, skip, limit, function (err, evts) {
    if (err) {
      return callback(err);
    }
    evts.next = function nextFn(callback) {
      if (limit &lt; 0) {
        var resEvts = [];
        resEvts.next = nextFn;
        return process.nextTick(function () { callback(null, resEvts) });
      }
      skip += limit;
      self.getEventsSince(commitStamp, skip, limit, callback);
    };

    callback(null, evts);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
by commitStamp

skip, limit always optional

var skip = 0,
    limit = 100; // if you omit limit or you define it as -1 it will retrieve until the end

es.<span class="apidocCodeKeywordSpan">getEventsSince</span>(new Date(2015, 5, 23), skip, limit, function(err, evts) {
  // if (events.length === amount) {
  //   events.next(function (err, nextEvts) {}); // just call next to retrieve the next page...
  // } else {
  //   // finished...
  // }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.getFromSnapshot" id="apidoc.element.eventstore.eventstore.prototype.getFromSnapshot">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getFromSnapshot
        <span class="apidocSignatureSpan">(query, revMax, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFromSnapshot = function (query, revMax, callback) {
  if (typeof revMax === 'function') {
    callback = revMax;
    revMax = -1;
  }

  if (typeof query === 'string') {
    query = { aggregateId: query };
  }

  if (!query.aggregateId) {
    var err = new Error('An aggregateId should be passed!');
    debug(err);
    if (callback) callback(err);
    return;
  }

  var self = this;

  async.waterfall([

    function getSnapshot(callback) {
      self.store.getSnapshot(query, revMax, callback);
    },

    function getEventStream(snap, callback) {
      var rev = 0;

      if (snap &amp;&amp; (snap.revision !== undefined &amp;&amp; snap.revision !== null)) {
        rev = snap.revision + 1;
      }

      self.getEventStream(query, rev, revMax, function(err, stream) {
        if (err) {
          return callback(err);
        }

        if (rev &gt; 0 &amp;&amp; stream.lastRevision == -1) {
          stream.lastRevision = snap.revision;
        }

        callback(null, snap, stream);
      });
    }],

    callback
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if you just want to load the last event as stream you can call getLastEventAsStream instead of getEventStream.


## working with snapshotting

get snapshot and eventhistory from the snapshot point

es.<span class="apidocCodeKeywordSpan">getFromSnapshot</span>('streamId', function(err, snapshot, stream) {
  var snap = snapshot.data;
  var history = stream.events; // events history from given snapshot

  // myAggregate.loadSnapshot(snap);
  // myAggregate.loadFromHistory(history);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.getLastEvent" id="apidoc.element.eventstore.eventstore.prototype.getLastEvent">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getLastEvent
        <span class="apidocSignatureSpan">(query, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastEvent = function (query, callback) {
  if (!callback) {
    callback = query;
    query = null;
  }

  if (typeof query === 'string') {
    query = { aggregateId: query };
  }

  this.store.getLastEvent(query, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // }
});


## get the last event
for example to obtain the last revision nr

es.<span class="apidocCodeKeywordSpan">getLastEvent</span>('streamId', function(err, evt) {
});

// or

es.getLastEvent({ // free choice (all, only context, only aggregate, only aggregateId...)
  context: 'hr',
  aggregate: 'person',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.getLastEventAsStream" id="apidoc.element.eventstore.eventstore.prototype.getLastEventAsStream">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getLastEventAsStream
        <span class="apidocSignatureSpan">(query, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastEventAsStream = function (query, callback) {
  if (!callback) {
    callback = query;
    query = null;
  }

  if (typeof query === 'string') {
    query = { aggregateId: query };
  }

  var self = this;

  this.store.getLastEvent(query, function (err, evt) {
    if (err) return callback(err);

    callback(null, new EventStream(self, query, evt ? [evt] : []));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.getNewId" id="apidoc.element.eventstore.eventstore.prototype.getNewId">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getNewId
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNewId = function (callback) {
  this.store.getNewId(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  aggregateId: 'uuid'
} function(err, evt) {
});


## obtain a new id

es.<span class="apidocCodeKeywordSpan">getNewId</span>(function(err, newId) {
  if(err) {
    console.log('ohhh :-(');
    return;
  }

  console.log('the new id is: ' + newId);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.getUndispatchedEvents" id="apidoc.element.eventstore.eventstore.prototype.getUndispatchedEvents">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>getUndispatchedEvents
        <span class="apidocSignatureSpan">(query, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUndispatchedEvents = function (query, callback) {
  if (!callback) {
    callback = query;
    query = null;
  }

  if (typeof query === 'string') {
    query = { aggregateId: query };
  }

  this.store.getUndispatchedEvents(query, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

});

You can automatically clean older snapshots by configuring the number of snapshots to keep with `maxSnapshotsCount` in `eventstore
` options.

## own event dispatching (no event publisher function defined)

es.<span class="apidocCodeKeywordSpan">getUndispatchedEvents</span>(function(err, evts) {
// or es.getUndispatchedEvents('streamId', function(err, evts) {
// or es.getUndispatchedEvents({ // free choice (all, only context, only aggregate, only aggregateId...)
//                                context: 'hr',
//                                aggregate: 'person',
//                                aggregateId: 'uuid'
//                              }, function(err, evts) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.init" id="apidoc.element.eventstore.eventstore.prototype.init">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>init
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (callback) {
  var self = this;

  function initDispatcher() {
    debug('init event dispatcher');
    self.dispatcher = new EventDispatcher(self.publisher, self);
    self.dispatcher.start(callback);
  }

  this.store.on('connect', function () {
    self.emit('connect');
  });

  this.store.on('disconnect', function () {
    self.emit('disconnect');
  });

  process.nextTick(function() {
    tolerate(function(callback) {
      self.store.connect(callback);
    }, self.options.timeout || 0, function (err) {
      if (err) {
        debug(err);
        if (callback) callback(err);
        return;
      }
      if (!self.publisher) {
        debug('no publisher defined');
        if (callback) callback(null);
        return;
      }
      initDispatcher();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  commitSequence: 'commitSequence',
  commitStamp: 'commitStamp',
  streamRevision: 'streamRevision'
});

## initialize

es.<span class="apidocCodeKeywordSpan">init</span>(function (err) {
  // this callback is called when all is ready...
});

// or

ex.init(); // callback is optional
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.setEventToDispatched" id="apidoc.element.eventstore.eventstore.prototype.setEventToDispatched">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>setEventToDispatched
        <span class="apidocSignatureSpan">(evtOrId, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEventToDispatched = function (evtOrId, callback) {
  if (typeof evtOrId === 'object') {
    evtOrId = evtOrId.id;
  }
  this.store.setEventToDispatched(evtOrId, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // all undispatched events
  console.log(evts);

  // dispatch it and set the event as dispatched

  for (var e in evts) {
    var evt = evts[r];
    es.<span class="apidocCodeKeywordSpan">setEventToDispatched</span>(evt, function(err) {});
    // or
    es.setEventToDispatched(evt.id, function(err) {});
  }

});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.eventstore.prototype.useEventPublisher" id="apidoc.element.eventstore.eventstore.prototype.useEventPublisher">
        function <span class="apidocSignatureSpan">eventstore.eventstore.prototype.</span>useEventPublisher
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">useEventPublisher = function (fn) {
  if (fn.length === 1) {
    fn = _.wrap(fn, function(func, evt, callback) {
      func(evt);
      callback(null);
    });
  }

  this.publisher = fn;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Built-in event publisher (optional)

if defined the eventstore will try to publish AND set event do dispatched on its own...

### sync interface

es.<span class="apidocCodeKeywordSpan">useEventPublisher</span>(function(evt) {
  // bus.emit('event', evt);
});

### async interface

es.useEventPublisher(function(evt, callback) {
  // bus.sendAndWaitForAck('event', evt, callback);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventstore.inmemory" id="apidoc.module.eventstore.inmemory">module eventstore.inmemory</a></h1>


    <h2>
        <a href="#apidoc.element.eventstore.inmemory.inmemory" id="apidoc.element.eventstore.inmemory.inmemory">
        function <span class="apidocSignatureSpan">eventstore.</span>inmemory
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InMemory(options) {
  Store.call(this, options);
  this.store = {};
  this.snapshots = {};
  this.undispatchedEvents = { _direct: {} };
  this.options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.super_" id="apidoc.element.eventstore.inmemory.super_">
        function <span class="apidocSignatureSpan">eventstore.inmemory.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Store(options) {
  options = options || {};

  EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventstore.inmemory.prototype" id="apidoc.module.eventstore.inmemory.prototype">module eventstore.inmemory.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.addEvents" id="apidoc.element.eventstore.inmemory.prototype.addEvents">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>addEvents
        <span class="apidocSignatureSpan">(events, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addEvents = function (events, callback) {
  if (!events || events.length === 0) {
    callback(null);
    return;
  }

  var found = _.find(events, function(evt) {
    return !evt.aggregateId;
  });

  if (found) {
    var errMsg = 'aggregateId not defined!';
    debug(errMsg);
    if (callback) callback(new Error(errMsg));
    return;
  }

  var aggregateId = events[0].aggregateId;
  var aggregate = events[0].aggregate || '_general';
  var context = events[0].context || '_general';

  this.store[context] = this.store[context] || {};
  this.store[context][aggregate] = this.store[context][aggregate] || {};
  this.store[context][aggregate][aggregateId] = this.store[context][aggregate][aggregateId] || [];
  this.store[context][aggregate][aggregateId] = this.store[context][aggregate][aggregateId].concat(events);

  this.undispatchedEvents[context] = this.undispatchedEvents[context] || {};
  this.undispatchedEvents[context][aggregate] = this.undispatchedEvents[context][aggregate] || {};
  this.undispatchedEvents[context][aggregate][aggregateId] = this.undispatchedEvents[context][aggregate][aggregateId] || [];
  this.undispatchedEvents[context][aggregate][aggregateId] = this.undispatchedEvents[context][aggregate][aggregateId].concat(events
);

  var self = this;
  _.forEach(events, function(evt) {
    self.undispatchedEvents._direct[evt.id] = evt;
  });

  callback(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// myAggregate.loadFromHistory(history);
    });

store a new event and commit it to store

    es.getEventStream('streamId', function(err, stream) {
stream.addEvent({ my: 'event' });
stream.<span class="apidocCodeKeywordSpan">addEvents</span>([{ my: 'event2' }]);

stream.commit();

// or

stream.commit(function(err, stream) {
  console.log(stream.eventsToDispatch); // this is an array containing all added events in this commit.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.addSnapshot" id="apidoc.element.eventstore.inmemory.prototype.addSnapshot">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>addSnapshot
        <span class="apidocSignatureSpan">(snap, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addSnapshot = function (snap, callback) {
  var aggregateId = snap.aggregateId;
  var aggregate = snap.aggregate || '_general';
  var context = snap.context || '_general';

  if (!snap.aggregateId) {
    var errMsg = 'aggregateId not defined!';
    debug(errMsg);
    if (callback) callback(new Error(errMsg));
    return;
  }

  this.snapshots[context] = this.snapshots[context] || {};
  this.snapshots[context][aggregate] = this.snapshots[context][aggregate] || {};
  this.snapshots[context][aggregate][aggregateId] = this.snapshots[context][aggregate][aggregateId] || [];

  this.snapshots[context][aggregate][aggregateId].push(snap);
  callback(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  try {
    var snap = new Snapshot(id, obj);
    snap.commitStamp = new Date();
  } catch (err) {
    return callback(err);
  }

  self.store.<span class="apidocCodeKeywordSpan">addSnapshot</span>(snap, function(error) {
    if (self.options.maxSnapshotsCount) {
      self.store.cleanSnapshots(_.pick(obj, 'aggregateId', 'aggregate', 'context'), callback);
    } else {
      callback(error);
    }
  });
}],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.cleanSnapshots" id="apidoc.element.eventstore.inmemory.prototype.cleanSnapshots">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>cleanSnapshots
        <span class="apidocSignatureSpan">(query, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanSnapshots = function (query, callback) {
  var aggregateId = query.aggregateId;
  var aggregate = query.aggregate || '_general';
  var context = query.context || '_general';

  if (!aggregateId) {
    var errMsg = 'aggregateId not defined!';
    debug(errMsg);
    if (callback) callback(new Error(errMsg));
    return;
  }

  var snapshots = this.snapshots[context][aggregate][aggregateId] || [];
  var length = snapshots.length;
  snapshots = snapshots.slice(-1 * this.options.maxSnapshotsCount);
  this.snapshots[context][aggregate][aggregateId] = snapshots;

  callback(null, length - snapshots.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        snap.commitStamp = new Date();
      } catch (err) {
        return callback(err);
      }

      self.store.addSnapshot(snap, function(error) {
        if (self.options.maxSnapshotsCount) {
          self.store.<span class="apidocCodeKeywordSpan">cleanSnapshots</span>(_.pick(obj, 'aggregateId', 'aggregate
', 'context'), callback);
        } else {
          callback(error);
        }
      });
    }],
  callback
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.clear" id="apidoc.element.eventstore.inmemory.prototype.clear">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>clear
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function (callback) {
  this.store = {};
  this.snapshots = {};
  this.undispatchedEvents = { _direct: {} };
  if (callback) callback(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.connect" id="apidoc.element.eventstore.inmemory.prototype.connect">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>connect
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (callback) {
  this.emit('connect');
  if (callback) callback(null, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this.store.on('disconnect', function () {
  self.emit('disconnect');
});

process.nextTick(function() {
  tolerate(function(callback) {
    self.store.<span class="apidocCodeKeywordSpan">connect</span>(callback);
  }, self.options.timeout || 0, function (err) {
    if (err) {
      debug(err);
      if (callback) callback(err);
      return;
    }
    if (!self.publisher) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.disconnect" id="apidoc.element.eventstore.inmemory.prototype.disconnect">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>disconnect
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function (callback) {
  this.emit('disconnect');
  if (callback) callback(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.getEvents" id="apidoc.element.eventstore.inmemory.prototype.getEvents">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>getEvents
        <span class="apidocSignatureSpan">(query, skip, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEvents = function (query, skip, limit, callback) {
  var res = [];
  for (var s in this.store) {
    for (var ss in this.store[s]) {
      for (var sss in this.store[s][ss]) {
        res = res.concat(this.store[s][ss][sss]);
      }
    }
  }

  res = _.sortBy(res, function (e) {
    return e.commitStamp.getTime();
  });

  if (!_.isEmpty(query)) {
    res = _.filter(res, function(e) {
      var keys = _.keys(query);
      var values = _.values(query);
      var found = false;
      for (var i in keys) {
        var key = keys[i];
        var deepFound = deepFind(e, key);
        if (_.isArray(deepFound) &amp;&amp; deepFound.length &gt; 0) {
          found = true;
        } else if (deepFound === values[i]) {
          found = true;
        } else {
          found = false;
          break;
        }
      }
      return found;
    });
  }

  if (limit === -1) {
    return callback(null, _.cloneDeep(res.slice(skip)));
  }

  if (res.length &lt;= skip) {
    return callback(null, []);
  }

  callback(null, _.cloneDeep(res.slice(skip, skip + limit)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for replaying your events or for rebuilding a viewmodel or just for fun...

skip, limit always optional

var skip = 0,
    limit = 100; // if you omit limit or you define it as -1 it will retrieve until the end

es.<span class="apidocCodeKeywordSpan">getEvents</span>(skip, limit, function(err, evts) {
  // if (events.length === amount) {
  //   events.next(function (err, nextEvts) {}); // just call next to retrieve the next page...
  // } else {
  //   // finished...
  // }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.getEventsByRevision" id="apidoc.element.eventstore.inmemory.prototype.getEventsByRevision">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>getEventsByRevision
        <span class="apidocSignatureSpan">(query, revMin, revMax, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEventsByRevision = function (query, revMin, revMax, callback) {
  var res = [];

  if (!query.aggregateId) {
    var errMsg = 'aggregateId not defined!';
    debug(errMsg);
    if (callback) callback(new Error(errMsg));
    return;
  }

  if (query.context &amp;&amp; query.aggregate) {
    this.store[query.context] = this.store[query.context] || {};
    this.store[query.context][query.aggregate] = this.store[query.context][query.aggregate] || {};

    if (!this.store[query.context][query.aggregate][query.aggregateId]) {
      return callback(null, _.cloneDeep(res));
    }
    else {
      if (revMax === -1) {
        res = res.concat(this.store[query.context][query.aggregate][query.aggregateId].slice(revMin));
      }
      else {
        res = res.concat(this.store[query.context][query.aggregate][query.aggregateId].slice(revMin, revMax));
      }
    }
    return callback(null, _.cloneDeep(res));
  }

  if (!query.context &amp;&amp; query.aggregate) {
    for (var s in this.store) {
      var c = this.store[s];
      if (c[query.aggregate] &amp;&amp; c[query.aggregate][query.aggregateId]) {
        if (revMax === -1) {
          res = res.concat(c[query.aggregate][query.aggregateId].slice(revMin));
        }
        else {
          res = res.concat(c[query.aggregate][query.aggregateId].slice(revMin, revMax));
        }
      }
    }
    return callback(null, _.cloneDeep(res));
  }

  if (query.context &amp;&amp; !query.aggregate) {
    var cc = this.store[query.context] || {};
    for (var ss in cc) {
      var a = cc[ss];
      if (a[query.aggregateId]) {
        if (revMax === -1) {
          res = res.concat(a[query.aggregateId].slice(revMin));
        }
        else {
          res = res.concat(a[query.aggregateId].slice(revMin, revMax));
        }
      }
    }
    return callback(null, _.cloneDeep(res));
  }

  if (!query.context &amp;&amp; !query.aggregate) {
    for (var sc in this.store) {
      var cont = this.store[sc];
      for (var sa in cont) {
        var agg = cont[sa];
        if (agg[query.aggregateId]) {
          if (revMax === -1) {
            res = res.concat(agg[query.aggregateId].slice(revMin));
          }
          else {
            res = res.concat(agg[query.aggregateId].slice(revMin, revMax));
          }
        }
      }
    }
    return callback(null, _.cloneDeep(res));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
by revision

revMin, revMax always optional

var revMin = 5,
    revMax = 8; // if you omit revMax or you define it as -1 it will retrieve until the end

es.<span class="apidocCodeKeywordSpan">getEventsByRevision</span>('streamId', revMin, revMax, function(err, evts) {});

// or

es.getEventsByRevision({
  aggregateId: 'myAggregateId',
  aggregate: 'person',          // optional
  context: 'hr'                 // optional
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.getEventsSince" id="apidoc.element.eventstore.inmemory.prototype.getEventsSince">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>getEventsSince
        <span class="apidocSignatureSpan">(date, skip, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEventsSince = function (date, skip, limit, callback) {
  var res = [];
  for (var s in this.store) {
    for (var ss in this.store[s]) {
      for (var sss in this.store[s][ss]) {
        res = res.concat(this.store[s][ss][sss]);
      }
    }
  }

  res = _.sortBy(res, function (e) {
    return e.commitStamp.getTime();
  });

  res = _.filter(res, function(e) {
    return e.commitStamp.getTime() &gt;= date.getTime();
  });

  if (limit === -1) {
    return callback(null, _.cloneDeep(res.slice(skip)));
  }

  if (res.length &lt;= skip) {
    return callback(null, []);
  }

  callback(null, _.cloneDeep(res.slice(skip, skip + limit)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
by commitStamp

skip, limit always optional

var skip = 0,
    limit = 100; // if you omit limit or you define it as -1 it will retrieve until the end

es.<span class="apidocCodeKeywordSpan">getEventsSince</span>(new Date(2015, 5, 23), skip, limit, function(err, evts) {
  // if (events.length === amount) {
  //   events.next(function (err, nextEvts) {}); // just call next to retrieve the next page...
  // } else {
  //   // finished...
  // }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.getLastEvent" id="apidoc.element.eventstore.inmemory.prototype.getLastEvent">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>getLastEvent
        <span class="apidocSignatureSpan">(query, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastEvent = function (query, callback) {
  if (!query.aggregateId) {
    var errMsg = 'aggregateId not defined!';
    debug(errMsg);
    if (callback) callback(new Error(errMsg));
    return;
  }

  var res = [];
  for (var s in this.store) {
    for (var ss in this.store[s]) {
      for (var sss in this.store[s][ss]) {
        res = res.concat(this.store[s][ss][sss]);
      }
    }
  }

  res = _.sortBy(res, function (e) {
    return e.commitStamp.getTime();
  });

  if (!_.isEmpty(query)) {
    res = _.filter(res, function(e) {
      var keys = _.keys(query);
      var values = _.values(query);
      var found = false;
      for (var i in keys) {
        var key = keys[i];
        var deepFound = deepFind(e, key);
        if (_.isArray(deepFound) &amp;&amp; deepFound.length &gt; 0) {
          found = true;
        } else if (deepFound === values[i]) {
          found = true;
        } else {
          found = false;
          break;
        }
      }
      return found;
    });
  }

  callback(null, res[res.length - 1]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // }
});


## get the last event
for example to obtain the last revision nr

es.<span class="apidocCodeKeywordSpan">getLastEvent</span>('streamId', function(err, evt) {
});

// or

es.getLastEvent({ // free choice (all, only context, only aggregate, only aggregateId...)
  context: 'hr',
  aggregate: 'person',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.getSnapshot" id="apidoc.element.eventstore.inmemory.prototype.getSnapshot">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>getSnapshot
        <span class="apidocSignatureSpan">(query, revMax, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSnapshot = function (query, revMax, callback) {

  if (!query.aggregateId) {
    var errMsg = 'aggregateId not defined!';
    debug(errMsg);
    if (callback) callback(new Error(errMsg));
    return;
  }

  var all = [];
  for (var s in this.snapshots) {
    for (var ss in this.snapshots[s]) {
      for (var sss in this.snapshots[s][ss]) {
        all = all.concat(this.snapshots[s][ss][sss]);
      }
    }
  }

//    all = _.sortBy(all, function (s) {
//      return [(-s.revision), (-s.version)].join('_');
//    });

  all = _.sortBy(all, function (s) {
    return (-s.commitStamp.getTime());
  });

  if (!_.isEmpty(query)) {
    all = _.filter(all, function(a) {
      var keys = _.keys(query);
      var values = _.values(query);
      var found = false;
      for (var i in keys) {
        var key = keys[i];
        var deepFound = deepFind(a, key);
        if (_.isArray(deepFound) &amp;&amp; deepFound.length &gt; 0) {
          found = true;
        } else if (deepFound === values[i]) {
          found = true;
        } else {
          found = false;
          break;
        }
      }
      return found;
    });
  }

  if (revMax === -1) {
    return callback(null, all[0] ? jsondate.parse(JSON.stringify(all[0])) : null);
  }
  else {
    for (var i = all.length - 1; i &gt;= 0; i--) {
      if (all[i].revision &lt;= revMax) {
        return callback(null, jsondate.parse(JSON.stringify(all[i])));
      }
    }
  }
  callback(null, null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var self = this;

    async.waterfall([

      function getSnapshot(callback) {
self.store.<span class="apidocCodeKeywordSpan">getSnapshot</span>(query, revMax, callback);
      },

      function getEventStream(snap, callback) {
var rev = 0;

if (snap &amp;&amp; (snap.revision !== undefined &amp;&amp; snap.revision !== null)) {
  rev = snap.revision + 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.getUndispatchedEvents" id="apidoc.element.eventstore.inmemory.prototype.getUndispatchedEvents">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>getUndispatchedEvents
        <span class="apidocSignatureSpan">(query, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUndispatchedEvents = function (query, callback) {
  var res = [];
  for (var s in this.undispatchedEvents) {
    if (s === '_direct') continue;
    for (var ss in this.undispatchedEvents[s]) {
      for (var sss in this.undispatchedEvents[s][ss]) {
        res = res.concat(this.undispatchedEvents[s][ss][sss]);
      }
    }
  }

  res = _.sortBy(res, function (e) {
    return e.commitStamp.getTime();
  });

  if (!_.isEmpty(query)) {
    res = _.filter(res, function(e) {
      var keys = _.keys(query);
      var values = _.values(query);
      var found = false;
      for (var i in keys) {
        var key = keys[i];
        var deepFound = deepFind(e, key);
        if (_.isArray(deepFound) &amp;&amp; deepFound.length &gt; 0) {
          found = true;
        } else if (deepFound === values[i]) {
          found = true;
        } else {
          found = false;
          break;
        }
      }
      return found;
    });
  }

  callback(null, res);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

});

You can automatically clean older snapshots by configuring the number of snapshots to keep with `maxSnapshotsCount` in `eventstore
` options.

## own event dispatching (no event publisher function defined)

es.<span class="apidocCodeKeywordSpan">getUndispatchedEvents</span>(function(err, evts) {
// or es.getUndispatchedEvents('streamId', function(err, evts) {
// or es.getUndispatchedEvents({ // free choice (all, only context, only aggregate, only aggregateId...)
//                                context: 'hr',
//                                aggregate: 'person',
//                                aggregateId: 'uuid'
//                              }, function(err, evts) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventstore.inmemory.prototype.setEventToDispatched" id="apidoc.element.eventstore.inmemory.prototype.setEventToDispatched">
        function <span class="apidocSignatureSpan">eventstore.inmemory.prototype.</span>setEventToDispatched
        <span class="apidocSignatureSpan">(id, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setEventToDispatched = function (id, callback) {
  var evt = this.undispatchedEvents._direct[id];
  var aggregateId = evt.aggregateId;
  var aggregate = evt.aggregate || '_general';
  var context = evt.context || '_general';

  this.undispatchedEvents[context][aggregate][aggregateId] = _.reject(this.undispatchedEvents[context][aggregate][aggregateId],
evt);
  delete this.undispatchedEvents._direct[id];
  callback(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // all undispatched events
  console.log(evts);

  // dispatch it and set the event as dispatched

  for (var e in evts) {
    var evt = evts[r];
    es.<span class="apidocCodeKeywordSpan">setEventToDispatched</span>(evt, function(err) {});
    // or
    es.setEventToDispatched(evt.id, function(err) {});
  }

});
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>